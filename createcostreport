#!/usr/bin/env python3

import pyexasol
import boto3
from datetime import datetime
from configparser import ConfigParser
import os
import sys
from pprint import pprint


config = ConfigParser()
config.read(os.path.join(os.path.dirname(__file__), ".exasolrc"))
DB_DSN = config.get("connection", "dsn")
DB_USER = config.get("connection", "user")
DB_PASSWORD = config.get("connection", "password")
DB_SCHEMA = config.get("connection", "schema")
AWS_PROD_SAAS_ACCOUNT = config.get("aws_accounts", "prod_saas")
AWS_PROD_SAAS_CUSTOMERS_ACCOUNT = config.get("aws_accounts", "prod_saas_customers")
AWS_PROD_SAAS_OFFLINE_BACKUPS_ACCOUNT = config.get(
    "aws_accounts", "prod_saas_offline_backups"
)

AWS_PROFILE = "166629205485_CostExplorerView"
ATTRIBUTION_TAG_KEY = "saas:AccountUUID"


def with_connection(callback):
    connection = None
    try:
        connection = pyexasol.connect(
            dsn=DB_DSN, user=DB_USER, password=DB_PASSWORD, schema=DB_SCHEMA
        )
        return callback(connection)
    except Exception as e:
        print(f"An error occurred: {e}")
    finally:
        if connection:
            connection.close()


def query(query, query_params=None):
    def execute_query(connection):
        result = connection.execute(query = query, query_params=query_params)
        return [row for row in result]

    return with_connection(execute_query)


def cost_data_to_hierarchy(cost_data):
    # Build a nested dict structure from cost_data
    def insert_path(tree, path, value):
        node = tree
        for key in path[:-1]:
            node = node.setdefault(key, {"children": {}, "sum": 0})
            node["sum"] += value
            node = node["children"]
        leaf = path[-1]
        node.setdefault(leaf, {"children": {}, "sum": 0})
        node[leaf]["sum"] += value

    # Build the tree and compute total sum
    tree = {}
    total = 0
    for d in cost_data:
        for k, v in d.items():
            insert_path(tree, k, v)
            total += v

    # Recursively compute percentages and clean up
    def compute_percentages(node, parent_sum, top_sum, is_top_level=False):
        node_sum = node.get("sum", 0)
        # category_percentage: for top-level, use total; for others, use top_sum
        if is_top_level:
            node["category_percentage"] = (
                round(100 * node_sum / total, 1) if total else 100.0
            )
        else:
            node["category_percentage"] = (
                round(100 * node_sum / top_sum, 1) if top_sum else 100.0
            )
        node["total_percentage"] = round(100 * node_sum / total, 1) if total else 100.0
        children = node.get("children", {})
        for key, child in children.items():
            compute_percentages(child, node_sum, top_sum, False)
        node.pop("sum", None)
        if children:
            node["children"] = dict(children)
        else:
            node.pop("children", None)

    # Compute percentages for all top-level nodes
    for key, node in tree.items():
        compute_percentages(node, total, node.get("sum", 0), is_top_level=True)

    return tree


def plot_cost_treemap(cost_data, title, filename):
    total_cost = sum(list(d.values())[0] for d in cost_data)
    title = f"{title}: ${total_cost:,.0f}"
    cost_hierarchy = cost_data_to_hierarchy(cost_data)
    import pandas as pd
    import plotly.express as px

    def build_data(node, path=None):
        data = []
        for key, value in node.items():
            current_path = (path or []) + [f"{key} ({value['category_percentage']}%)"]
            children = value.get("children")
            if children:
                data += build_data(children, current_path)
            else:
                # Only add parent categories to path, leaf node as label
                row = (
                    (path or [])
                    + [f"{key}<br>({value['category_percentage']}%)"]
                    + [value["total_percentage"]]
                )
                data.append(row)
        return data

    data = build_data(cost_hierarchy)
    if not data:
        print("No data to plot.")
        return

    num_cats = len(data[0]) - 2  # Subtract label and percentage
    cat_columns = [f"Cat {i+1}" for i in range(num_cats)]
    columns = cat_columns + ["Label", "Percentage"]

    df = pd.DataFrame(data, columns=columns)
    fig = px.treemap(df, path=cat_columns + ["Label"], values="Percentage", title=title)
    fig.update_layout(
        height=800,
        width=1600,
        margin=dict(l=10, r=10, t=60, b=10),  # smaller margins
        title_font=dict(size=18)
    )
    fig.write_image(filename, scale=2)


class CostFetcher:
    def __init__(self, start_date, end_date, account_uuid):
        self.start_date = start_date
        self.end_date = end_date
        self.account_uuid = account_uuid
        self.client = self._get_aws_client()

    def _get_aws_client(self):
        aws_access_key = os.getenv("AWS_ACCESS_KEY_ID")
        aws_secret_key = os.getenv("AWS_SECRET_ACCESS_KEY")
        aws_session_token = os.getenv("AWS_SESSION_TOKEN")
        aws_region = os.getenv("AWS_DEFAULT_REGION", "us-east-1")

        if not aws_access_key or not aws_secret_key:
            credentials_path = os.path.expanduser("~/.aws/credentials")
            if os.path.exists(credentials_path):
                config = ConfigParser()
                config.read(credentials_path)
                aws_access_key = config.get(
                    AWS_PROFILE, "aws_access_key_id", fallback=None
                )
                aws_secret_key = config.get(
                    AWS_PROFILE, "aws_secret_access_key", fallback=None
                )
                aws_session_token = config.get(
                    AWS_PROFILE, "aws_session_token", fallback=None
                )
                aws_region = config.get(AWS_PROFILE, "region", fallback=aws_region)

        if not aws_access_key or not aws_secret_key:
            raise EnvironmentError(
                "AWS credentials not set in environment variables or ~/.aws/credentials file."
            )

        return boto3.client(
            "ce",
            aws_access_key_id=aws_access_key,
            aws_secret_access_key=aws_secret_key,
            aws_session_token=aws_session_token,
            region_name=aws_region,
        )

    def get_cost_and_usage(
        self,
        linked_accounts,
        usage_key=None,
        usage_values=None,
        additional_filters=None,
    ):
        filters = {
            "And": [
                {"Tags": {"Key": ATTRIBUTION_TAG_KEY, "Values": [self.account_uuid]}},
                {
                    "Dimensions": {
                        "Key": "RECORD_TYPE",
                        "Values": ["Usage", "SavingsPlanCoveredUsage"],
                    }
                },
                {"Dimensions": {"Key": "LINKED_ACCOUNT", "Values": linked_accounts}},
            ]
        }
        if usage_key and usage_values:
            filters["And"].insert(
                2,
                {
                    "Dimensions": {
                        "Key": usage_key,
                        "Values": usage_values,
                    }
                },
            )
        if additional_filters:
            filters["And"].extend(additional_filters)
        response = self.client.get_cost_and_usage(
            TimePeriod={"Start": self.start_date, "End": self.end_date},
            Granularity="MONTHLY",
            Metrics=["UnblendedCost"],
            Filter=filters,
        )
        results = response.get("ResultsByTime", [])
        total = 0.0
        for result in results:
            total += float(result["Total"]["UnblendedCost"]["Amount"])
        return round(total, 2)

    def get_traffic_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_CUSTOMERS_ACCOUNT, AWS_PROD_SAAS_OFFLINE_BACKUPS_ACCOUNT],
            "USAGE_TYPE_GROUP",
            ["EC2: Data Transfer - Internet (Out)"],
        )

    def get_ebs_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_CUSTOMERS_ACCOUNT, AWS_PROD_SAAS_OFFLINE_BACKUPS_ACCOUNT],
            "USAGE_TYPE_GROUP",
            [
                "EC2: EBS - SSD(gp2)",
                "EC2: EBS - SSD(gp3)",
                "EC2: EBS - Snapshots",
                "EC2: EBS Optimized",
            ],
        )

    def get_access_node_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_CUSTOMERS_ACCOUNT],
            "USAGE_TYPE_GROUP",
            ["EC2: Running Hours"],
            [{"Tags": {"Key": "aws:cloudformation:logical-id", "Values": ["n10"]}}],
        )

    def get_ec2_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_CUSTOMERS_ACCOUNT],
            "USAGE_TYPE_GROUP",
            ["EC2: Running Hours"],
            [
                {
                    "Not": {
                        "Tags": {
                            "Key": "aws:cloudformation:logical-id",
                            "Values": ["n10"],
                        }
                    }
                }
            ],
        )

    def get_s3_storage_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_CUSTOMERS_ACCOUNT],
            "USAGE_TYPE_GROUP",
            ["S3: Storage - Standard"],
        )

    def get_s3_storage_api_request_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_CUSTOMERS_ACCOUNT],
            "USAGE_TYPE_GROUP",
            ["S3: API Requests - Standard"],
        )

    def get_offline_backups_s3_storage_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_OFFLINE_BACKUPS_ACCOUNT],
            "USAGE_TYPE_GROUP",
            ["S3: Storage - Standard"],
        )

    def get_offline_backups_s3_api_requests_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_OFFLINE_BACKUPS_ACCOUNT],
            "USAGE_TYPE_GROUP",
            ["S3: API Requests - Standard"],
        )

    def get_vpc_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_CUSTOMERS_ACCOUNT, AWS_PROD_SAAS_OFFLINE_BACKUPS_ACCOUNT],
            "SERVICE",
            ["Amazon Virtual Private Cloud"],
        )

    def get_total_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_CUSTOMERS_ACCOUNT, AWS_PROD_SAAS_OFFLINE_BACKUPS_ACCOUNT]
        )

    def get_dimension_values(self, usage_key):
        response = self.client.get_dimension_values(
            TimePeriod={"Start": self.start_date, "End": self.end_date},
            Dimension=usage_key,
        )
        values = response.get("DimensionValues", [])
        return [value["Value"] for value in values]


class Costs(dict):
    def __init__(self, company, status, account_uuid, start_date, end_date):
        super().__init__()
        self.company = company if company else "UNKNOWN"
        self.status = status
        self.account_uuid = account_uuid
        self.start_date = start_date
        self.end_date = end_date

    def __getitem__(self, key):
        return super().__getitem__(key)

    def __setitem__(self, key, value):
        super().__setitem__(key, value)

    def __repr__(self):
        return f"Costs(company={self.company}, status={self.status}, account_uuid={self.account_uuid}, start_date={start_date}, end_date={end_date}, costs={dict(self)})"


def get_account_costs(company, status, account_uuid, start_date, end_date):
    costs = Costs(company, status, account_uuid, start_date, end_date)
    fetcher = CostFetcher(start_date, end_date, account_uuid)
    total_costs = fetcher.get_total_costs()
    if total_costs == 0:
        print(
            f"No costs found for {company} ({account_uuid}) from {start_date} to {end_date}."
        )
        return None

    costs["EBS"] = fetcher.get_ebs_costs()
    costs["Access Node"] = fetcher.get_access_node_costs()
    costs["EC2"] = fetcher.get_ec2_costs()
    costs["DB S3 Stroage"] = fetcher.get_s3_storage_costs()
    costs["Traffic"] = fetcher.get_traffic_costs()
    costs["DB S3 Storage API Requests"] = fetcher.get_s3_storage_api_request_costs()
    costs["Offline Backup S3 Storage"] = fetcher.get_offline_backups_s3_storage_costs()
    costs["Offline Backup S3 API Request"] = (
        fetcher.get_offline_backups_s3_api_requests_costs()
    )
    costs["VPC"] = fetcher.get_vpc_costs()
    total_attributed_costs = sum(costs.values())
    costs["Other"] = round(total_costs - total_attributed_costs, 2)
    return costs


def create_cost_treemap(costs):
    cost_data = []
    for key, value in costs.items():
        cost_data.append({(key,): value})

    costomer_name_sanitized = costs.company.replace(" ", "_").replace("/", "_")
    plot_cost_treemap(
        cost_data,
        f"{costs.company} ({costs.status})<br>{costs.start_date} - {costs.end_date}",
        f"./treemaps/{costomer_name_sanitized} {costs.account_uuid} {costs.start_date}-{costs.end_date}.png",
    )
    return costs


def save_cost_reports(all_costs):
    def save_costs_to_db(con):
        for costs in all_costs:
            print(
                f"Saving costs to DB for {costs.company} ({costs.account_uuid}) from {costs.start_date} to {costs.end_date}:"
            )
            for key, value in costs.items():
                con.execute(
                    query="""
                        MERGE INTO aws_cost_report c
                        USING VALUES ({company}, {account_uuid}, {cost_category}, {start_date}, {end_date}, {cost}, {status}) AS t(compamy, account_uuid, cost_category, start_date, end_date, cost, status)
                        ON t.account_uuid = c.account_uuid AND t.start_date = c.start_date AND t.end_date = c.end_date AND t.cost_category = c.cost_category
                        WHEN MATCHED THEN
                            UPDATE SET cost = {cost}, company = {company}, status = {status}
                        WHEN NOT MATCHED THEN
                            INSERT (company, account_uuid, cost_category, start_date, end_date, cost, status)
                            VALUES ({company}, {account_uuid}, {cost_category}, {start_date}, {end_date}, {cost}, {status})
                        """,
                    query_params={
                        "company": costs.company,
                        "account_uuid": costs.account_uuid,
                        "start_date": costs.start_date,
                        "end_date": costs.end_date,
                        "cost_category": key,
                        "cost": value,
                        "status": costs.status,
                    },
                ),

    with_connection(save_costs_to_db)


def get_costs_from_db(start_date, end_date):
    result = query(
        """
            SELECT company, status, account_uuid, cost_category, start_date, end_date, cost
            FROM aws_cost_report
            WHERE start_date >= {start_date} AND end_date <= {end_date}
            ORDER BY account_uuid, start_date, end_date, cost_category
            """,
            query_params={
                "start_date": start_date,        
                "end_date": end_date,
            }
    )
    rows = [row for row in result]
    costs_dict = {}
    for row in rows:
        company, status, account_uuid, cost_category, s_date, e_date, cost = row
        key = (account_uuid, s_date, e_date)
        if key not in costs_dict:
            s_date = s_date.split()[0]
            e_date = e_date.split()[0]
            costs_dict[key] = Costs(company, status, account_uuid, s_date, e_date)
        costs_dict[key][cost_category] = float(cost)
    return list(costs_dict.values())

def get_all_account_costs(start_date, end_date):
    customers = query(
        """
        SELECT DISTINCT account_uuid, company, status 
        FROM consumption_report
    """
    )
    all_costs = []
    for customer in customers:
        account_uuid = customer[0]
        company = customer[1]
        status = customer[2]
        print(
            f"Getting costs for {company} ({account_uuid}) from {start_date} to {end_date}:"
        )
        costs = get_account_costs(company, status, account_uuid, start_date, end_date)
        if costs:
            all_costs.append(costs)
    return all_costs


def create_cost_treemaps(start_date, end_date):
    all_costs = get_costs_from_db(start_date, end_date)
    for costs in all_costs:
        print(
            f"Creating Treemap for {costs.company} ({costs.account_uuid}) from {costs.start_date} to {costs.end_date}:"
        )
        create_cost_treemap(costs)



if __name__ == "__main__":
    args = sys.argv[1:]
    get_costs_flag = False

    # Check if --getcosts is present anywhere in the args
    if "--getcosts" in args:
        get_costs_flag = True
        args.remove("--getcosts")

    if len(args) < 2:
        print(f"Usage: {sys.argv[0]} [--getcosts] <start_date:YYYY-MM-DD> <end_date:YYYY-MM-DD>")
        sys.exit(1)

    start_date = args[0]
    end_date = args[1]

    # Validate date format
    try:
        datetime.strptime(start_date, "%Y-%m-%d")
        datetime.strptime(end_date, "%Y-%m-%d")
    except ValueError:
        print("Dates must be in YYYY-MM-DD format.")
        sys.exit(1)

    if get_costs_flag:
        print("Getting costs from AWS and creating cost treemaps...")
        all_costs = get_all_account_costs(start_date, end_date)
        save_cost_reports(all_costs)
    else:
        print("Creating cost treemaps from existing costs in DB...")
    create_cost_treemaps(start_date, end_date)
