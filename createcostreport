#!/usr/bin/env python3

import pyexasol
import boto3
from datetime import datetime
from configparser import ConfigParser
import os
import sys
from pprint import pprint
import argparse


config = ConfigParser()
config.read(os.path.join(os.path.dirname(__file__), ".exasolrc"))
DB_DSN = config.get("connection", "dsn")
DB_USER = config.get("connection", "user")
DB_PASSWORD = config.get("connection", "password")
DB_SCHEMA = config.get("connection", "schema")
AWS_PROD_SAAS_ACCOUNT = config.get("aws_accounts", "prod_saas")
AWS_PROD_SAAS_CUSTOMERS_ACCOUNT = config.get("aws_accounts", "prod_saas_customers")
AWS_PROD_SAAS_OFFLINE_BACKUPS_ACCOUNT = config.get(
    "aws_accounts", "prod_saas_offline_backups"
)

AWS_PROFILE = "166629205485_CostExplorerView"
ATTRIBUTION_TAG_KEY = "saas:AccountUUID"


def with_connection(callback):
    connection = None
    try:
        connection = pyexasol.connect(
            dsn=DB_DSN, user=DB_USER, password=DB_PASSWORD, schema=DB_SCHEMA
        )
        return callback(connection)
    except Exception as e:
        print(f"An error occurred: {e}")
    finally:
        if connection:
            connection.close()


def query(query, query_params=None):
    def execute_query(connection):
        result = connection.execute(query = query, query_params=query_params)
        return [row for row in result]

    return with_connection(execute_query)


def cost_data_to_hierarchy(cost_data):
    # Build a nested dict structure from cost_data
    def insert_path(tree, path, value):
        node = tree
        for key in path[:-1]:
            node = node.setdefault(key, {"children": {}, "sum": 0})
            node["sum"] += value
            node = node["children"]
        leaf = path[-1]
        node.setdefault(leaf, {"children": {}, "sum": 0})
        node[leaf]["sum"] += value

    # Build the tree and compute total sum
    tree = {}
    total = 0
    for d in cost_data:
        for k, v in d.items():
            insert_path(tree, k, v)
            total += v

    # Recursively compute percentages and clean up
    def compute_percentages(node, parent_sum, top_sum, is_top_level=False):
        node_sum = node.get("sum", 0)
        # category_percentage: for top-level, use total; for others, use top_sum
        if is_top_level:
            node["category_percentage"] = (
                round(100 * node_sum / total, 1) if total else 100.0
            )
        else:
            node["category_percentage"] = (
                round(100 * node_sum / top_sum, 1) if top_sum else 100.0
            )
        node["total_percentage"] = round(100 * node_sum / total, 1) if total else 100.0
        children = node.get("children", {})
        for key, child in children.items():
            compute_percentages(child, node_sum, top_sum, False)
        node.pop("sum", None)
        if children:
            node["children"] = dict(children)
        else:
            node.pop("children", None)

    # Compute percentages for all top-level nodes
    for key, node in tree.items():
        compute_percentages(node, total, node.get("sum", 0), is_top_level=True)

    return tree


def plot_cost_treemap(cost_data, title, filename):
    total_cost = sum(list(d.values())[0] for d in cost_data)
    title = f"{title}: ${total_cost:,.0f}"
    cost_hierarchy = cost_data_to_hierarchy(cost_data)
    import pandas as pd
    import plotly.express as px

    def build_data(node, path=None):
        data = []
        for key, value in node.items():
            current_path = (path or []) + [f"{key} ({value['category_percentage']}%)"]
            children = value.get("children")
            if children:
                data += build_data(children, current_path)
            else:
                # Only add parent categories to path, leaf node as label
                row = (
                    (path or [])
                    + [f"{key}<br>({value['category_percentage']}%)"]
                    + [value["total_percentage"]]
                )
                data.append(row)
        return data

    data = build_data(cost_hierarchy)
    if not data:
        print("No data to plot.")
        return

    num_cats = len(data[0]) - 2  # Subtract label and percentage
    cat_columns = [f"Cat {i+1}" for i in range(num_cats)]
    columns = cat_columns + ["Label", "Percentage"]

    df = pd.DataFrame(data, columns=columns)
    fig = px.treemap(df, path=cat_columns + ["Label"], values="Percentage", title=title)
    fig.update_layout(
        height=800,
        width=1600,
        margin=dict(l=10, r=10, t=60, b=10),  # smaller margins
        title_font=dict(size=18)
    )
    fig.write_image(filename, scale=2)


class CostFetcher:
    def __init__(self, start_date, end_date, account_uuid):
        self.start_date = start_date
        self.end_date = end_date
        self.account_uuid = account_uuid
        self.client = self._get_aws_client()

    def _get_aws_client(self):
        aws_access_key = os.getenv("AWS_ACCESS_KEY_ID")
        aws_secret_key = os.getenv("AWS_SECRET_ACCESS_KEY")
        aws_session_token = os.getenv("AWS_SESSION_TOKEN")
        aws_region = os.getenv("AWS_DEFAULT_REGION", "us-east-1")

        if not aws_access_key or not aws_secret_key:
            credentials_path = os.path.expanduser("~/.aws/credentials")
            if os.path.exists(credentials_path):
                config = ConfigParser()
                config.read(credentials_path)
                aws_access_key = config.get(
                    AWS_PROFILE, "aws_access_key_id", fallback=None
                )
                aws_secret_key = config.get(
                    AWS_PROFILE, "aws_secret_access_key", fallback=None
                )
                aws_session_token = config.get(
                    AWS_PROFILE, "aws_session_token", fallback=None
                )
                aws_region = config.get(AWS_PROFILE, "region", fallback=aws_region)

        if not aws_access_key or not aws_secret_key:
            raise EnvironmentError(
                "AWS credentials not set in environment variables or ~/.aws/credentials file."
            )

        return boto3.client(
            "ce",
            aws_access_key_id=aws_access_key,
            aws_secret_access_key=aws_secret_key,
            aws_session_token=aws_session_token,
            region_name=aws_region,
        )

    def get_cost_and_usage(
        self,
        linked_accounts,
        usage_key=None,
        usage_values=None,
        additional_filters=None,
    ):
        filters = {
            "And": [
                {"Tags": {"Key": ATTRIBUTION_TAG_KEY, "Values": [self.account_uuid]}},
                {
                    "Dimensions": {
                        "Key": "RECORD_TYPE",
                        "Values": ["Usage", "SavingsPlanCoveredUsage"],
                    }
                },
                {"Dimensions": {"Key": "LINKED_ACCOUNT", "Values": linked_accounts}},
            ]
        }
        if usage_key and usage_values:
            filters["And"].insert(
                2,
                {
                    "Dimensions": {
                        "Key": usage_key,
                        "Values": usage_values,
                    }
                },
            )
        if additional_filters:
            filters["And"].extend(additional_filters)
        response = self.client.get_cost_and_usage(
            TimePeriod={"Start": self.start_date, "End": self.end_date},
            Granularity="MONTHLY",
            Metrics=["UnblendedCost"],
            Filter=filters,
        )
        results = response.get("ResultsByTime", [])
        total = 0.0
        for result in results:
            total += float(result["Total"]["UnblendedCost"]["Amount"])
        return round(total, 2)

    def get_traffic_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_CUSTOMERS_ACCOUNT, AWS_PROD_SAAS_OFFLINE_BACKUPS_ACCOUNT],
            "USAGE_TYPE_GROUP",
            ["EC2: Data Transfer - Internet (Out)"],
        )

    def get_ebs_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_CUSTOMERS_ACCOUNT, AWS_PROD_SAAS_OFFLINE_BACKUPS_ACCOUNT],
            "USAGE_TYPE_GROUP",
            [
                "EC2: EBS - SSD(gp2)",
                "EC2: EBS - SSD(gp3)",
                "EC2: EBS - Snapshots",
                "EC2: EBS Optimized",
            ],
        )

    def get_access_node_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_CUSTOMERS_ACCOUNT],
            "USAGE_TYPE_GROUP",
            ["EC2: Running Hours"],
            [{"Tags": {"Key": "aws:cloudformation:logical-id", "Values": ["n10"]}}],
        )

    def get_ec2_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_CUSTOMERS_ACCOUNT],
            "USAGE_TYPE_GROUP",
            ["EC2: Running Hours"],
            [
                {
                    "Not": {
                        "Tags": {
                            "Key": "aws:cloudformation:logical-id",
                            "Values": ["n10"],
                        }
                    }
                }
            ],
        )

    def get_s3_storage_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_CUSTOMERS_ACCOUNT],
            "USAGE_TYPE_GROUP",
            ["S3: Storage - Standard"],
        )

    def get_s3_storage_api_request_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_CUSTOMERS_ACCOUNT],
            "USAGE_TYPE_GROUP",
            ["S3: API Requests - Standard"],
        )

    def get_offline_backups_s3_storage_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_OFFLINE_BACKUPS_ACCOUNT],
            "USAGE_TYPE_GROUP",
            ["S3: Storage - Standard"],
        )

    def get_offline_backups_s3_api_requests_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_OFFLINE_BACKUPS_ACCOUNT],
            "USAGE_TYPE_GROUP",
            ["S3: API Requests - Standard"],
        )

    def get_vpc_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_CUSTOMERS_ACCOUNT, AWS_PROD_SAAS_OFFLINE_BACKUPS_ACCOUNT],
            "SERVICE",
            ["Amazon Virtual Private Cloud"],
        )

    def get_total_costs(self):
        return self.get_cost_and_usage(
            [AWS_PROD_SAAS_CUSTOMERS_ACCOUNT, AWS_PROD_SAAS_OFFLINE_BACKUPS_ACCOUNT]
        )

    def get_dimension_values(self, usage_key):
        response = self.client.get_dimension_values(
            TimePeriod={"Start": self.start_date, "End": self.end_date},
            Dimension=usage_key,
        )
        values = response.get("DimensionValues", [])
        return [value["Value"] for value in values]


class Costs(dict):
    def __init__(self, company, status, account_uuid, start_date, end_date):
        super().__init__()
        self.company = company if company else "UNKNOWN"
        self.status = status
        self.account_uuid = account_uuid
        self.start_date = start_date
        self.end_date = end_date

    def __getitem__(self, key):
        return super().__getitem__(key)

    def __setitem__(self, key, value):
        super().__setitem__(key, value)

    def __repr__(self):
        return f"Costs(company={self.company}, status={self.status}, account_uuid={self.account_uuid}, start_date={self.start_date}, end_date={self.end_date}, costs={dict(self)})"


def get_company_costs_from_aws(company, status, account_uuid, start_date, end_date):
    costs = Costs(company, status, account_uuid, start_date, end_date)
    fetcher = CostFetcher(start_date, end_date, account_uuid)
    total_costs = fetcher.get_total_costs()
    if total_costs == 0:
        print(
            f"No costs found for {company} ({account_uuid}) from {start_date} to {end_date}."
        )
        return None

    costs["EBS"] = fetcher.get_ebs_costs()
    costs["Access Node"] = fetcher.get_access_node_costs()
    costs["EC2"] = fetcher.get_ec2_costs()
    costs["DB S3 Stroage"] = fetcher.get_s3_storage_costs()
    costs["Traffic"] = fetcher.get_traffic_costs()
    costs["DB S3 Storage API Requests"] = fetcher.get_s3_storage_api_request_costs()
    costs["Offline Backup S3 Storage"] = fetcher.get_offline_backups_s3_storage_costs()
    costs["Offline Backup S3 API Request"] = (
        fetcher.get_offline_backups_s3_api_requests_costs()
    )
    costs["VPC"] = fetcher.get_vpc_costs()
    total_attributed_costs = sum(costs.values())
    costs["Other"] = round(total_costs - total_attributed_costs, 2)
    return costs


def create_cost_treemap(costs):
    cost_data = []
    for key, value in costs.items():
        cost_data.append({(key,): value})

    if not costs.company:
        costs.company = "UNKNOWN"
    costomer_name_sanitized = costs.company.replace(" ", "_").replace("/", "_")
    plot_cost_treemap(
        cost_data,
        f"{costs.company} ({costs.status})<br>{costs.start_date} - {costs.end_date}",
        f"./treemaps/{costomer_name_sanitized} {costs.account_uuid} {costs.start_date}-{costs.end_date}.png",
    )
    return costs


def save_cost_reports_to_db(all_costs):
    def save_costs_to_db(con):
        for costs in all_costs:
            print(
                f"Saving costs to DB for {costs.company} ({costs.account_uuid}) from {costs.start_date} to {costs.end_date}:"
            )
            for key, value in costs.items():
                con.execute(
                    query="""
                        MERGE INTO aws_cost_report c
                        USING VALUES ({account_uuid}, {company}, {start_date}, {cost_category}, {cost}, {status}) AS t(account_uuid, company, start_date, cost_category, cost, status)
                        ON t.account_uuid = c.account_uuid AND t.start_date = c.start_date AND t.cost_category = c.cost_category
                        WHEN MATCHED THEN
                            UPDATE SET cost = {cost}, company = {company}, status = {status}
                        WHEN NOT MATCHED THEN
                            INSERT (account_uuid, company, start_date, cost_category, cost, status)
                            VALUES ({account_uuid}, {company}, {start_date}, {cost_category}, {cost}, {status})
                    """,
                    query_params={
                        "account_uuid": costs['account_uuid'],
                        "company": costs['company'],
                        "start_date": costs['start_date'],
                        "cost_category": key,
                        "cost": value,
                        "status": costs['status'],
                    },
                ),

    with_connection(save_costs_to_db)


def get_costs_from_db(start_date, end_date):
    result = query(
        """
            SELECT company, status, account_uuid, cost_category, start_date, end_date, cost
            FROM aws_cost_report
            WHERE start_date = {start_date} AND end_date = {end_date}
            ORDER BY account_uuid, start_date, end_date, cost_category
            """,
            query_params={
                "start_date": start_date,        
                "end_date": end_date,
            }
    )
    rows = [row for row in result]
    costs_dict = {}
    for row in rows:
        company, status, account_uuid, cost_category, s_date, e_date, cost = row
        key = (account_uuid, s_date, e_date)
        if key not in costs_dict:
            s_date = s_date.split()[0]
            e_date = e_date.split()[0]
            costs_dict[key] = Costs(company, status, account_uuid, s_date, e_date)
        costs_dict[key][cost_category] = float(cost)
    return list(costs_dict.values())

def get_all_account_costs(start_date, end_date):
    customers = query(
        """
        SELECT DISTINCT account_uuid, company, status 
        FROM consumption_report
    """
    )
    all_costs = []
    for customer in customers:
        account_uuid = customer[0]
        company = customer[1]
        status = customer[2]
        print(
            f"Getting costs for {company} ({account_uuid}) from {start_date} to {end_date}:"
        )
        costs = get_company_costs_from_aws(company, status, account_uuid, start_date, end_date)
        if costs:
            all_costs.append(costs)
    return all_costs


def create_cost_treemaps(start_date, end_date):
    all_costs = get_costs_from_db(start_date, end_date)
    for costs in all_costs:
        print(
            f"Creating Treemap for {costs.company} ({costs.account_uuid}) from {costs.start_date} to {costs.end_date}:"
        )
        create_cost_treemap(costs)



def save_costs_to_db(all_costs, con):
    for costs in all_costs:
        print(f"Saving costs to DB for {costs['company']} ({costs['account_uuid']}) for {costs['start_date']}:")
        for category, value in costs['categories'].items():
            con.execute(
                query="""
                    MERGE INTO aws_cost_report c
                    USING VALUES ({account_uuid}, {company}, {start_date}, {cost_category}, {cost}, {status}) AS t(account_uuid, company, start_date, cost_category, cost, status)
                    ON t.account_uuid = c.account_uuid AND t.start_date = c.start_date AND t.cost_category = c.cost_category
                    WHEN MATCHED THEN
                        UPDATE SET cost = {cost}, company = {company}, status = {status}
                    WHEN NOT MATCHED THEN
                        INSERT (account_uuid, company, start_date, cost_category, cost, status)
                        VALUES ({account_uuid}, {company}, {start_date}, {cost_category}, {cost}, {status})
                """,
                query_params={
                    "account_uuid": costs['account_uuid'],
                    "company": costs['company'],
                    "start_date": costs['start_date'],
                    "cost_category": category,
                    "cost": value,
                    "status": costs['status'],
                },
            )
        


def get_costs_from_aws_and_save_to_db(months, con, account_uuids=[]):
    for month in months:
        year, month = map(int, month.split('-'))
        start_date = f"{year}-{month:02d}-01"
        if month == 12:
            end_date = f"{year + 1}-01-01"
        else:
            end_date = f"{year}-{month + 1:02d}-01"

        query_str = """
            SELECT account_uuid, company, status 
            FROM customers
        """
        query_params = {}

        if account_uuids:
            query_str += " WHERE account_uuid IN ({account_uuids})"
            query_params["account_uuids"] = account_uuids

        customers = con.execute(query_str, query_params=query_params)

        for customer in customers:
            account_uuid, company, status = customer
            print(f"Getting costs for {company} ({account_uuid}) for {year}-{month:02d}:")

            # Fetch costs for the current company
            fetcher = CostFetcher(start_date, end_date, account_uuid)
            total_costs = fetcher.get_total_costs()
            if total_costs == 0:
                print(f"No costs found for {company} ({account_uuid}) for {year}-{month:02d}.")
                continue

            # Prepare cost data
            costs = {
                "account_uuid": account_uuid,
                "company": company,
                "start_date": start_date,
                "status": status,
                "categories": {
                    "EBS": fetcher.get_ebs_costs(),
                    "Access Node": fetcher.get_access_node_costs(),
                    "EC2": fetcher.get_ec2_costs(),
                    "DB S3 Storage": fetcher.get_s3_storage_costs(),
                    "Traffic": fetcher.get_traffic_costs(),
                    "DB S3 Storage API Requests": fetcher.get_s3_storage_api_request_costs(),
                    "Offline Backup S3 Storage": fetcher.get_offline_backups_s3_storage_costs(),
                    "Offline Backup S3 API Request": fetcher.get_offline_backups_s3_api_requests_costs(),
                    "VPC": fetcher.get_vpc_costs(),
                },
            }
            total_attributed_costs = sum(costs['categories'].values())
            costs['categories']["Other"] = round(total_costs - total_attributed_costs, 2)
            save_costs_to_db([costs], con)


def create_company_cost_treemaps_for_month(month, account_uuids=None):
    year, month = map(int, month.split('-'))
    start_date = f"{year}-{month:02d}-01"
    query_str = """
        SELECT company, account_uuid, cost_category, cost, status
        FROM aws_cost_report
        WHERE start_date = {start_date}
    """
    query_params = {"start_date": start_date}

    if account_uuids:
        query_str += " AND account_uuid IN ({account_uuids})"
        query_params["account_uuids"] = account_uuids

    result = query(query_str, query_params=query_params)

    costs_by_company = {}
    for row in result:
        company = row[0]
        account_uuid = row[1]
        category = row[2]
        cost = float(row[3])
        status = row[4]
        if company not in costs_by_company:
            costs_by_company[company] = {
                "account_uuid": account_uuid,
                "status": status,
                "categories": {},
            }
        costs_by_company[company]['categories'][category] = cost

    for company, data in costs_by_company.items():
        print(f"Creating Treemap for {company} ({data['account_uuid']}) for {start_date}:")
        cost_data = [{(category,): value} for category, value in data['categories'].items()]
        if not company:
            company = "UNKNOWN"
        sanitized_name = company.replace(" ", "_").replace("/", "_")
        plot_cost_treemap(
            cost_data,
            f"{company} ({data['status']})<br>{start_date}",
            f"./treemaps/{sanitized_name} {data['account_uuid']} {start_date}.png",
        )


def create_summary_treemap_for_months(start_date, end_date, account_uuids=[], title="summary_treemap"):
    query_str = """
        SELECT SUM(cost) AS cost, cost_category
        FROM aws_cost_report
        WHERE start_date >= {start_date} AND start_date < {end_date}
    """
    query_params = {"start_date": start_date, "end_date": end_date}

    if account_uuids:
        query_str += " AND account_uuid IN ({account_uuids})"
        query_params["account_uuids"] = account_uuids

    query_str += " GROUP BY cost_category"

    result = query(query_str, query_params=query_params)

    cost_data = []
    for row in result:
        cost = float(row[0])
        category = row[1]
        cost_data.append({(category,): cost})

    file_name = f"./treemaps/{title}_{start_date}_to_{end_date}.png"
    print(f"Creating Summary Treemap for {start_date} to {end_date} at {file_name}:")

    plot_cost_treemap(
        cost_data,
        f"{title}<br>{start_date} to {end_date}",
        file_name,
    )


def create_summary_treemap_from_sql(sql_script, start_date, end_date, title="summary_treemap"):
    with open(sql_script, 'r') as file:
        sql_query = file.read()

    query_params = {"start_date": start_date, "end_date": end_date}
    result = query(sql_query, query_params=query_params)

    cost_data = []
    for row in result:
        cost = float(row[0])
        category = row[1]
        cost_data.append({(category,): cost})

    file_name = f"./treemaps/{title}_{start_date}_to_{end_date}.png"
    print(f"Creating Summary Treemap from SQL script ({sql_script}) at {file_name}:")
    plot_cost_treemap(
        cost_data,
        title,
        file_name,
    )


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Cost Report Management")
    subparsers = parser.add_subparsers(dest="command", required=True)

    # Subparser for the "get-costs" command
    getcosts_parser = subparsers.add_parser("get-costs", help="Fetch costs from AWS and save to DB")
    getcosts_parser.add_argument("months", nargs="+", help="List of months in YYYY-MM format")
    getcosts_parser.add_argument("--account-uuids", type=lambda s: s.split(','), help="Optional comma-separated list of account UUIDs")

    # Subparser for the "create-company-treemaps" command
    company_treemap_parser = subparsers.add_parser("create-company-treemaps", help="Create company-specific cost treemaps")
    company_treemap_parser.add_argument("month", help="Month in YYYY-MM format")
    company_treemap_parser.add_argument("--account-uuids", type=lambda s: s.split(','), help="Optional comma-separated list of account UUIDs")

    # Subparser for the "create-summary-treemap" command
    summary_treemap_parser = subparsers.add_parser("create-summary-treemap", help="Create a summary treemap")
    summary_treemap_parser.add_argument("start_date", help="Start date in YYYY-MM-DD format")
    summary_treemap_parser.add_argument("end_date", nargs="?", help="Optional end date in YYYY-MM-DD format")
    
    group = summary_treemap_parser.add_mutually_exclusive_group()
    group.add_argument("--account-uuids", type=lambda s: s.split(','), help="Optional comma-separated list of account UUIDs")
    group.add_argument("--sql-script", help="Path to an SQL script file to execute")
    summary_treemap_parser.add_argument("--title", help="Optional title for the treemap")

    args = parser.parse_args()

    if args.command == "get-costs":
        print(f"Getting costs from AWS and saving to DB for months={args.months}, account_uuids={args.account_uuids}...")
        def process_costs(con):
            get_costs_from_aws_and_save_to_db(args.months, con, args.account_uuids)
        with_connection(process_costs)

    elif args.command == "create-company-treemaps":
        print("Creating cost treemaps from existing costs in DB...")
        create_company_cost_treemaps_for_month(args.month, args.account_uuids)

    elif args.command == "create-summary-treemap":
        print(f"Creating summary treemap for start_date={args.start_date}, end_date={args.end_date}, account_uuids={args.account_uuids}, sql_script={args.sql_script}, title={args.title}...")
        if args.sql_script:
            create_summary_treemap_from_sql(args.sql_script, args.start_date, args.end_date, args.title)
        else:
            create_summary_treemap_for_months(args.start_date, args.end_date, args.account_uuids, args.title)
    else:
        print(f"Unknown command: {args.command}")
        sys.exit(1)
    